apiVersion: v1
kind: ConfigMap
metadata:
  name: pod-autoheal
  namespace: monitoring
  labels:
    app.kubernetes.io/name: pod-autoheal
    app.kubernetes.io/instance: pod-autoheal-prod
    app.kubernetes.io/part-of: homelab
    app.kubernetes.io/managed-by: flux
    exposure: internal
data:
  autoheal.py: |
    #!/usr/bin/env python3
    import json
    import os
    import ssl
    import urllib.error
    import urllib.parse
    import urllib.request
    from datetime import datetime, timedelta, timezone

    WATCH_REASONS = {"CrashLoopBackOff", "ImagePullBackOff", "ErrImagePull"}
    EXCLUDED_NAMESPACES = {
      "kube-system",
      "kube-public",
      "kube-node-lease",
      "cert-manager",
      "flux-system",
      "external-dns",
    }
    AGE_THRESHOLD = timedelta(minutes=10)
    STATE_TTL = timedelta(hours=24)
    STATE_CM = "pod-autoheal-state"
    STATE_NS = "monitoring"

    API_HOST = os.environ.get("KUBERNETES_SERVICE_HOST", "kubernetes.default.svc")
    API_PORT = os.environ.get("KUBERNETES_SERVICE_PORT", "443")
    API_BASE = f"https://{API_HOST}:{API_PORT}"
    TELEGRAM_TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN", "").strip()
    TELEGRAM_CHAT_ID = os.environ.get("TELEGRAM_CHAT_ID", "").strip()

    def now():
      return datetime.now(timezone.utc)

    def parse_ts(value):
      if not value:
        return None
      return datetime.fromisoformat(value.replace("Z", "+00:00"))

    def api_request(path, method="GET", body=None, query=None, content_type="application/json"):
      token_path = "/var/run/secrets/kubernetes.io/serviceaccount/token"
      ca_path = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
      with open(token_path, "r", encoding="utf-8") as handle:
        token = handle.read().strip()
      url = f"{API_BASE}{path}"
      if query:
        url = f"{url}?{urllib.parse.urlencode(query, doseq=True)}"
      data = None
      headers = {"Authorization": f"Bearer {token}"}
      if body is not None:
        data = json.dumps(body).encode("utf-8")
        headers["Content-Type"] = content_type
      req = urllib.request.Request(url, data=data, headers=headers, method=method)
      ctx = ssl.create_default_context(cafile=ca_path)
      with urllib.request.urlopen(req, context=ctx, timeout=20) as response:
        raw = response.read().decode("utf-8")
        return json.loads(raw) if raw else {}

    def api_request_allow_404(path):
      try:
        return api_request(path)
      except urllib.error.HTTPError as err:
        if err.code == 404:
          return None
        raise

    def load_state():
      cm = api_request_allow_404(f"/api/v1/namespaces/{STATE_NS}/configmaps/{STATE_CM}")
      if not cm:
        return {}
      try:
        return json.loads(cm.get("data", {}).get("state", "{}"))
      except json.JSONDecodeError:
        return {}

    def save_state(state):
      payload = {
        "metadata": {"name": STATE_CM, "namespace": STATE_NS},
        "data": {"state": json.dumps(state, separators=(",", ":"))},
      }
      path = f"/api/v1/namespaces/{STATE_NS}/configmaps/{STATE_CM}"
      existing = api_request_allow_404(path)
      if existing is None:
        create = {"apiVersion": "v1", "kind": "ConfigMap"}
        create.update(payload)
        api_request(f"/api/v1/namespaces/{STATE_NS}/configmaps", method="POST", body=create)
      else:
        api_request(path, method="PATCH", body=payload, content_type="application/merge-patch+json")

    def get_events_snippet(namespace, pod_name):
      events = api_request(
        f"/api/v1/namespaces/{namespace}/events",
        query={"fieldSelector": f"involvedObject.name={pod_name},type=Warning", "limit": 50},
      ).get("items", [])
      if not events:
        return ""
      events.sort(key=lambda e: e.get("lastTimestamp") or e.get("eventTime") or e.get("metadata", {}).get("creationTimestamp") or "")
      msg = events[-1].get("message", "")
      return msg[:700]

    def get_log_snippet(namespace, pod_name, container_name):
      try:
        data = api_request(
          f"/api/v1/namespaces/{namespace}/pods/{pod_name}/log",
          query={"container": container_name, "tailLines": 40},
        )
      except Exception:
        return ""
      # /log returns plain text but helper parses JSON; fallback by direct call:
      if isinstance(data, dict):
        token_path = "/var/run/secrets/kubernetes.io/serviceaccount/token"
        ca_path = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
        with open(token_path, "r", encoding="utf-8") as handle:
          token = handle.read().strip()
        ctx = ssl.create_default_context(cafile=ca_path)
        q = urllib.parse.urlencode({"container": container_name, "tailLines": 40})
        req = urllib.request.Request(
          f"{API_BASE}/api/v1/namespaces/{namespace}/pods/{pod_name}/log?{q}",
          headers={"Authorization": f"Bearer {token}"},
          method="GET",
        )
        try:
          with urllib.request.urlopen(req, context=ctx, timeout=20) as response:
            txt = response.read().decode("utf-8", errors="replace")
            return txt[-1200:]
        except Exception:
          return ""
      return str(data)[-1200:]

    def resolve_workload_owner(namespace, pod):
      refs = pod.get("metadata", {}).get("ownerReferences", [])
      if not refs:
        return None
      owner = refs[0]
      kind = owner.get("kind")
      name = owner.get("name")
      if kind in {"Deployment", "StatefulSet", "DaemonSet"}:
        return kind, name
      if kind == "ReplicaSet":
        rs = api_request_allow_404(f"/apis/apps/v1/namespaces/{namespace}/replicasets/{name}")
        if not rs:
          return None
        for rs_owner in rs.get("metadata", {}).get("ownerReferences", []):
          if rs_owner.get("kind") == "Deployment":
            return "Deployment", rs_owner.get("name")
      return None

    def restart_workload(namespace, owner_kind, owner_name):
      kind_path = {
        "Deployment": "deployments",
        "StatefulSet": "statefulsets",
        "DaemonSet": "daemonsets",
      }.get(owner_kind)
      if not kind_path:
        return False, f"unsupported owner kind {owner_kind}"
      patch = {
        "spec": {
          "template": {
            "metadata": {
              "annotations": {
                "autoheal.romanpeters.nl/restarted-at": now().isoformat()
              }
            }
          }
        }
      }
      try:
        api_request(
          f"/apis/apps/v1/namespaces/{namespace}/{kind_path}/{owner_name}",
          method="PATCH",
          body=patch,
          content_type="application/merge-patch+json",
        )
        return True, "rollout restart triggered"
      except Exception as exc:
        return False, str(exc)

    def send_telegram(message):
      if not TELEGRAM_TOKEN or not TELEGRAM_CHAT_ID:
        return
      url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage"
      payload = json.dumps(
        {
          "chat_id": TELEGRAM_CHAT_ID,
          "text": message[:3900],
          "disable_web_page_preview": True,
        }
      ).encode("utf-8")
      req = urllib.request.Request(url, data=payload, headers={"Content-Type": "application/json"}, method="POST")
      try:
        with urllib.request.urlopen(req, timeout=20):
          pass
      except Exception:
        pass

    def main():
      current = now()
      state = load_state()
      pods = api_request("/api/v1/pods").get("items", [])
      active_keys = set()

      for pod in pods:
        namespace = pod.get("metadata", {}).get("namespace", "")
        if namespace in EXCLUDED_NAMESPACES:
          continue

        pod_name = pod.get("metadata", {}).get("name", "")
        created_at = parse_ts(pod.get("metadata", {}).get("creationTimestamp")) or current
        age = current - created_at
        if age < AGE_THRESHOLD:
          continue

        statuses = []
        statuses.extend(pod.get("status", {}).get("containerStatuses", []) or [])
        statuses.extend(pod.get("status", {}).get("initContainerStatuses", []) or [])

        for status in statuses:
          waiting = (status.get("state") or {}).get("waiting")
          if not waiting:
            continue
          reason = waiting.get("reason", "")
          if reason not in WATCH_REASONS:
            continue

          container = status.get("name", "unknown")
          key = f"{namespace}/{pod_name}/{container}/{reason}"
          active_keys.add(key)
          entry = state.get(key, {"first_seen": current.isoformat(), "action": "pending"})
          first_seen = parse_ts(entry.get("first_seen")) or current

          if current - first_seen < AGE_THRESHOLD:
            state[key] = entry
            continue
          if entry.get("action") == "restarted":
            state[key] = entry
            continue

          owner = resolve_workload_owner(namespace, pod)
          if not owner:
            entry["action"] = "no-owner"
            entry["last_action_at"] = current.isoformat()
            state[key] = entry
            continue

          owner_kind, owner_name = owner
          ok, restart_msg = restart_workload(namespace, owner_kind, owner_name)
          entry["action"] = "restarted" if ok else "restart-failed"
          entry["owner"] = f"{owner_kind}/{owner_name}"
          entry["last_action_at"] = current.isoformat()
          state[key] = entry

          snippet = get_log_snippet(namespace, pod_name, container)
          if not snippet:
            snippet = get_events_snippet(namespace, pod_name)
          if not snippet:
            snippet = "No logs/events available."
          snippet = snippet.replace("\r", "").strip()
          if len(snippet) > 900:
            snippet = snippet[-900:]

          message = (
            f"[Autoheal] {reason} for {namespace}/{pod_name} ({container})\n"
            f"Owner: {owner_kind}/{owner_name}\n"
            f"Action: {restart_msg}\n\n"
            f"Snippet:\n{snippet}"
          )
          send_telegram(message)

      # Garbage collect stale state
      retained = {}
      for key, value in state.items():
        ts = parse_ts(value.get("last_action_at")) or parse_ts(value.get("first_seen")) or current
        if key in active_keys or current - ts < STATE_TTL:
          retained[key] = value
      save_state(retained)

    if __name__ == "__main__":
      main()
