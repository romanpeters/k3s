apiVersion: v1
kind: ConfigMap
metadata:
  name: alertmanager-ntfy-relay
  namespace: monitoring
data:
  relay.py: |
    import json
    import os
    import sys
    from http.server import BaseHTTPRequestHandler, HTTPServer
    from urllib.request import Request, urlopen
    from urllib.error import URLError, HTTPError

    NTFY_URL = os.environ.get("NTFY_URL", "http://ntfy.monitoring.svc.cluster.local/alerts")
    LISTEN = os.environ.get("LISTEN", "0.0.0.0")
    PORT = int(os.environ.get("PORT", "8080"))

    def _severity(alert):
        return (alert.get("labels", {}) or {}).get("severity", "").lower()

    def _priority(severities):
        if "critical" in severities:
            return "5"
        if "warning" in severities:
            return "4"
        return "3"

    def _tags(severities):
        tags = ["k8s", "alertmanager"]
        if "critical" in severities:
            tags.append("rotating_light")
        elif "warning" in severities:
            tags.append("warning")
        return ",".join(tags)

    def _render(payload):
        alerts = payload.get("alerts", []) or []
        status = (payload.get("status") or "firing").upper()
        common = payload.get("commonLabels", {}) or {}
        title = common.get("alertname") or f"{len(alerts)} alert(s)"
        title = f"{status}: {title}"

        lines = []
        for alert in alerts:
            labels = alert.get("labels", {}) or {}
            annotations = alert.get("annotations", {}) or {}
            name = labels.get("alertname", "Alert")
            summary = annotations.get("summary", "")
            description = annotations.get("description", "")
            namespace = labels.get("namespace", "")
            pod = labels.get("pod", "")

            section = [name]
            if summary:
                section.append(summary)
            if description:
                section.append(description)
            meta = []
            if namespace:
                meta.append(f"ns={namespace}")
            if pod:
                meta.append(f"pod={pod}")
            if meta:
                section.append(" ".join(meta))
            lines.append("\n".join(section))

        message = "\n\n".join(lines) if lines else json.dumps(payload, indent=2)
        severities = {_severity(a) for a in alerts if _severity(a)}
        return title, message, severities

    class Handler(BaseHTTPRequestHandler):
        def do_GET(self):
            if self.path in ("/health", "/"):
                self.send_response(200)
                self.end_headers()
                self.wfile.write(b"ok")
                return
            self.send_response(404)
            self.end_headers()

        def do_POST(self):
            length = int(self.headers.get("content-length", "0"))
            body = self.rfile.read(length) if length > 0 else b"{}"
            try:
                payload = json.loads(body.decode("utf-8"))
            except json.JSONDecodeError:
                self.send_response(400)
                self.end_headers()
                self.wfile.write(b"invalid json")
                return

            title, message, severities = _render(payload)
            headers = {
                "Content-Type": "text/plain; charset=utf-8",
                "X-Title": title,
                "X-Priority": _priority(severities),
                "X-Tags": _tags(severities),
            }
            try:
                req = Request(NTFY_URL, data=message.encode("utf-8"), headers=headers, method="POST")
                with urlopen(req, timeout=5) as resp:
                    resp.read()
            except (HTTPError, URLError) as exc:
                sys.stderr.write(f"ntfy publish failed: {exc}\\n")
                self.send_response(502)
                self.end_headers()
                self.wfile.write(b"ntfy publish failed")
                return

            self.send_response(200)
            self.end_headers()
            self.wfile.write(b"ok")

    def main():
        server = HTTPServer((LISTEN, PORT), Handler)
        print(f"listening on {LISTEN}:{PORT}", flush=True)
        server.serve_forever()

    if __name__ == "__main__":
        main()
