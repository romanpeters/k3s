apiVersion: v1
kind: ConfigMap
metadata:
  name: trivy-fixable-exporter
  namespace: monitoring
  labels:
    app.kubernetes.io/name: trivy-fixable-exporter
    app.kubernetes.io/instance: trivy-fixable-exporter-prod
    app.kubernetes.io/part-of: homelab
    app.kubernetes.io/managed-by: flux
    exposure: internal
data:
  exporter.py: |
    #!/usr/bin/env python3
    import json
    import os
    import ssl
    from collections import defaultdict
    from http.server import BaseHTTPRequestHandler, HTTPServer
    from urllib.parse import quote
    from urllib.request import Request, urlopen

    TOKEN_PATH = "/var/run/secrets/kubernetes.io/serviceaccount/token"
    CA_PATH = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
    API_HOST = os.environ.get("KUBERNETES_SERVICE_HOST", "kubernetes.default.svc")
    API_PORT = os.environ.get("KUBERNETES_SERVICE_PORT", "443")
    API_BASE = f"https://{API_HOST}:{API_PORT}"
    FIXABLE_METRIC = "trivy_image_fixable_vulnerabilities"
    ERROR_METRIC = "trivy_fixable_exporter_scrape_error"

    with open(TOKEN_PATH, "r", encoding="utf-8") as token_file:
      TOKEN = token_file.read().strip()

    SSL_CONTEXT = ssl.create_default_context(cafile=CA_PATH)

    def escape(value: str) -> str:
      return value.replace("\\", "\\\\").replace("\"", "\\\"").replace("\n", "\\n")

    def is_fixable(fixed_version) -> bool:
      if fixed_version is None:
        return False
      fixed = str(fixed_version).strip()
      return fixed not in {"", "<none>", "none", "n/a", "na", "N/A", "NA"}

    def list_vulnerability_reports():
      items = []
      cont = ""
      while True:
        url = f"{API_BASE}/apis/aquasecurity.github.io/v1alpha1/vulnerabilityreports?limit=500"
        if cont:
          url += f"&continue={quote(cont)}"
        req = Request(url, headers={"Authorization": f"Bearer {TOKEN}"})
        with urlopen(req, context=SSL_CONTEXT, timeout=20) as response:
          payload = json.loads(response.read().decode("utf-8"))
        items.extend(payload.get("items", []))
        cont = payload.get("metadata", {}).get("continue", "")
        if not cont:
          return items

    def collect_fixable_counts():
      counts = defaultdict(int)
      for report in list_vulnerability_reports():
        meta = report.get("metadata", {})
        labels = meta.get("labels", {})
        namespace = meta.get("namespace", "")
        resource_kind = labels.get("trivy-operator.resource.kind", "")
        resource_name = labels.get("trivy-operator.resource.name", "")
        artifact = report.get("report", {}).get("artifact", {})
        image_repository = artifact.get("repository", "")
        image_tag = artifact.get("tag", "")
        for vuln in report.get("report", {}).get("vulnerabilities", []):
          if not is_fixable(vuln.get("fixedVersion")):
            continue
          sev = str(vuln.get("severity", "")).strip().upper()
          if sev not in {"CRITICAL", "HIGH"}:
            continue
          severity = sev.title()
          key = (
            namespace,
            resource_kind,
            resource_name,
            image_repository,
            image_tag,
            severity,
          )
          counts[key] += 1
      return counts

    class Handler(BaseHTTPRequestHandler):
      def do_GET(self):
        if self.path != "/metrics":
          self.send_response(404)
          self.end_headers()
          return

        lines = [
          f"# HELP {FIXABLE_METRIC} Number of fixable vulnerabilities per image and severity.",
          f"# TYPE {FIXABLE_METRIC} gauge",
          f"# HELP {ERROR_METRIC} 1 when exporter scrape failed, else 0.",
          f"# TYPE {ERROR_METRIC} gauge",
        ]
        try:
          counts = collect_fixable_counts()
          for (
            namespace,
            resource_kind,
            resource_name,
            image_repository,
            image_tag,
            severity,
          ), value in sorted(counts.items()):
            labels = (
              f'namespace="{escape(namespace)}",'
              f'resource_kind="{escape(resource_kind)}",'
              f'resource_name="{escape(resource_name)}",'
              f'image_repository="{escape(image_repository)}",'
              f'image_tag="{escape(image_tag)}",'
              f'severity="{escape(severity)}"'
            )
            lines.append(f"{FIXABLE_METRIC}{{{labels}}} {value}")
          lines.append(f"{ERROR_METRIC} 0")
        except Exception:
          lines.append(f"{ERROR_METRIC} 1")

        body = ("\n".join(lines) + "\n").encode("utf-8")
        self.send_response(200)
        self.send_header("Content-Type", "text/plain; version=0.0.4; charset=utf-8")
        self.send_header("Content-Length", str(len(body)))
        self.end_headers()
        self.wfile.write(body)

      def log_message(self, fmt, *args):
        return

    if __name__ == "__main__":
      port = int(os.environ.get("PORT", "9102"))
      server = HTTPServer(("0.0.0.0", port), Handler)
      server.serve_forever()
